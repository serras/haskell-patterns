# Function-related

### Function composition

### Memoization

### Defunctionalisation

### Difference Encoding


# Data Types

## Algebraic Structure

### Semigroup and Monoid

## Focused Mutability

### Lenses

###  Zipper / Derivative

## Generic Operations

### Builder

### Parser

### Generic Diff and Patch

## Composition and Abstraction

### Compositional Data Types / Data Types Ã  la Carte

### Higher Order Parametric Data Types

### Generic Programming


# Encapsulation

### Adapter via Type Classes

### Smart constructor

### Views

### Default records

### Abstract Data Type

### Restriction

### Non-scaping

### Newtypes


# Containers and Origami

### Functor as Container

### Fold / Catamorphism / Initial algebra / Attribute grammar

### Unfold / Anamorphism / Final algebra

### More recursion schemes


# Computational Context

### Functor as Context

### Applicative

### Monad

### MonadFix / Circular Programming

### Alternative, MonadPlus and ArrowPlus

### Semigrupoid and Category

### Arrow

### Comonad


# Functors

### Functor composition

### Contravariant Functor

### Profunctor

### Traversable

### Distributive


# Domain-Specific Languages

### Combinator library

### Shallow embedding

### Deep embedding


# Separation of Concerns

### Monad Transformers

### Extensible Effects / Algebraic Handlers

### Data Transformation / Streams

### Dataflow / Reducers

### Reactive / Event

### Transactions

### Messaging / Mailbox / Channels

## Aside: Pipes as a Generalization


# Basic Effects

### Identity

### Reader / Writer / State

### Errors / Exceptions

### Non-determinism / Backtracking

### Resource Management

### Pool

### Continuations


# Dependent Types

### Internal properties / Indexing

### External properties

### Ornamentation

### Protocol

### Indexed Computations

## Impasse: type-level programming in Haskell


# Free Structures
